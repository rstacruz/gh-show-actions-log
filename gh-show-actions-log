#!/usr/bin/env node

import { execSync } from 'node:child_process'
import { basename } from 'node:path'

const BIN = basename(process.argv[1] ?? 'gh-show-actions-log')

/**
 * @typedef {{ ok: true, result: string } | { ok: false, code: number }} ExecCommandResult
 */

// Constants
const TIMEOUT_SECS = 20 * 60
const INTERVAL_SECS = 10
const WORKFLOW_WAIT_SECS = 10
const SUMMARY_DISPLAY_FREQUENCY = 6

/** @type {Array<'in_progress' | 'queued'>} */
const ACTIVE_STATUSES = ['in_progress', 'queued']

// ANSI color codes
const colors = {
  bold: '\x1b[0;1m',
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[1;33m',
  blue: '\x1b[0;34m',
  dim: '\x1b[2m',
  reset: '\x1b[0m',
}

/** The main action */
class ShowLogAction {
  /**
   * @param {string} error
   */
  static showUsageAndExit(error) {
    Output.error(error)
    Output.log()
    Output.log(`Usage: ${BIN} [repo] [commit-sha]`)
    Output.log(`Example: ${BIN}                     # current repo, current commit`)
    Output.log(`Example: ${BIN} owner/repo abc1234  # specific repo and commit`)
    process.exit(1)
  }

  /**
   * @param {string} repo
   * @param {string} commitSha
   */
  static async waitForRunningRuns(repo, commitSha) {
    let elapsed = 0
    let steps = 0

    Output.info('Waiting for running workflows to complete...')

    while (elapsed < TIMEOUT_SECS) {
      steps = (steps + 1) % SUMMARY_DISPLAY_FREQUENCY
      const allRuns = GhCli.getRuns(repo, commitSha)
      if (steps === 0) ShowLogAction.displayRunSummary(allRuns)

      const hasFailure = allRuns.filter(run => run.conclusion === 'failure').length > 0
      const hasPending = allRuns.filter((run) => ACTIVE_STATUSES.includes(run.status)).length > 0

      if (hasFailure || !hasPending) {
        break
      }

      await Util.sleep(INTERVAL_SECS * 1000)
      elapsed += INTERVAL_SECS
    }

    if (elapsed >= TIMEOUT_SECS) {
      Output.warning('Timeout reached. Workflow may still be running.')
      process.exit(2)
    }
  }

  /**
   * @param {Array<any>} runs
   */
  static displayRunSummary(runs) {
    if (runs.length === 0) return
    Output.log()

    const hasPending = runs.filter((run) => ACTIVE_STATUSES.includes(run.status)).length > 0

    if (hasPending) {
      // As of right now
      Output.log(`As of ${(new Date()).toLocaleString()}:`)
    } else {
      const lastUpdatedIso = runs.map(run => run.updatedAt).sort().reverse()[0]
      const lastUpdatedDate = new Date(Date.parse(lastUpdatedIso))
      Output.log(`As of ${lastUpdatedDate.toLocaleString()} (${Util.formatDuration(lastUpdatedDate, new Date())} ago):`)
    }
    Output.log()

    for (const run of runs) {
      const status = Util.formatStatus(run.status, run.conclusion)
      const now = run.status === "in_progress" ? new Date() : run.updatedAt
      const duration = Util.formatDuration(run.startedAt, now)
      Output.log(`- ${status}: ${run.workflowName} (${run.event}) - ${duration}`)
    }
  }

  /**
   * @param {string} repo
   * @param {Array<any>} failedRuns
   */
  static async processFailedRuns(repo, failedRuns) {
    for (const run of failedRuns) {
      const jobs = GhCli.getFailedJobsByRun(repo, run.databaseId)

      for (const job of jobs) {
        Output.h2(`Failed job: ${run.workflowName} / ${job.name} (${run.event})`)
        //  (run: ${run.databaseId}, job: ${job.databaseId})`,

        Output.log()
        Output.log('`````')
        const logs = GhCli.getJobLogs(repo, job.databaseId)
        if (logs) {
          Output.log(logs)
          Output.log()
        } else {
          Output.warning(`Could not fetch logs for job ${job.databaseId}`)
        }
        Output.log('`````')

        const url = `https://github.com/${repo}/actions/runs/${run.databaseId}/job/${job.databaseId}`
        Output.log()
        Output.log(`> Log URL: ${url}`)
      }
    }
  }

  static async main() {
    // Parse arguments
    const args = process.argv.slice(2)
    let repo = args[0]
    let commitSha = args[1]

    // Get repository if not provided
    if (!repo) {
      const repoResult = GhCli.getRepo()
      if (!repoResult.ok) {
        return ShowLogAction.showUsageAndExit('Could not determine repository.')
      }
      repo = repoResult.result
    }

    // Validate that if repo was explicitly provided, commit must also be provided
    if (args[0] && !args[1]) {
      return ShowLogAction.showUsageAndExit(
        'When specifying a repository, also specify a commit SHA.',
      )
    }

    // Get SHA if not provided
    if (!commitSha) {
      const shaResult = GitCli.getCurrentSha()
      if (!shaResult.ok) {
        return ShowLogAction.showUsageAndExit('Could not determine current commit SHA.')
      }
      commitSha = shaResult.result
    }

    // Validate SHA format
    if (!Util.validateSha(commitSha)) {
      Output.error(`Invalid SHA format: '${commitSha}'. Must be 7-40 hex characters.`)
      process.exit(1)
    }

    const shortSha = commitSha.substring(0, 7)

    Output.h1(`GitHub Actions runs for ${repo} @ ${shortSha}`)

    // Fetch all runs for the commit and display summary
    let allRuns = GhCli.getRuns(repo, commitSha)

    if (allRuns.length === 0) {
      Output.info(`No workflow runs found, trying again in ${WORKFLOW_WAIT_SECS} seconds...`)
      await Util.sleep(WORKFLOW_WAIT_SECS * 1000)
      allRuns = GhCli.getRuns(repo, commitSha)
    }

    ShowLogAction.displayRunSummary(allRuns)

    if (allRuns.length === 0) {
      Output.success('No runs found')
      process.exit(0)
    }

    const hasFailure = allRuns.filter(run => run.conclusion === 'failure').length > 0
    const hasPending = allRuns.filter((run) => ACTIVE_STATUSES.includes(run.status)).length > 0

    // Process running runs
    if (!hasFailure && hasPending) {
      await ShowLogAction.waitForRunningRuns(repo, commitSha)

      // Refetch all runs after waiting
      allRuns = GhCli.getRuns(repo, commitSha)

      ShowLogAction.displayRunSummary(allRuns)
    }

    // Get failed runs
    const failedRuns = allRuns.filter((run) => run.conclusion === 'failure')

    if (failedRuns.length === 0) {
      Output.success(`${allRuns.length} ${allRuns.length === 1 ? 'run' : 'runs'} successful âœ“`)
      process.exit(0)
    }

    // Process failed runs
    await ShowLogAction.processFailedRuns(repo, failedRuns)

    Output.warning(
      `${failedRuns.length} of ${allRuns.length} runs failed, see logs above for details.`,
    )
    process.exit(64)
  }
}

/** GitHub CLI wrapper class */
class GhCli {
  static getRepo() {
    return Util.execCommand("gh repo view --json nameWithOwner -q '.nameWithOwner'")
  }

  /**
   * @param {string} repo
   * @param {string} [commitSha]
   */
  static getRuns(repo, commitSha) {
    const commitFlag = commitSha ? `--commit=${commitSha}` : ''
    const outputResult = Util.execCommand(
      `gh run list --repo "${repo}" ${commitFlag} --json databaseId,headBranch,workflowName,createdAt,status,conclusion,startedAt,updatedAt,event --jq '.[]'`,
    )
    return outputResult.ok ? Util.parseJsonLines(outputResult.result) : []
  }

  /**
   * @param {string} repo
   * @param {number} runId
   */
  static getFailedJobsByRun(repo, runId) {
    const outputResult = Util.execCommand(
      `gh run view --repo "${repo}" "${runId}" --json jobs --jq '.jobs[] | select(.conclusion == "failure") | {name: .name, databaseId: .databaseId}'`,
    )
    return outputResult.ok ? Util.parseJsonLines(outputResult.result) : []
  }

  /**
   * @param {string} repo
   * @param {number} jobId
   */
  static getJobLogs(repo, jobId) {
    const logsResult = Util.execCommand(`gh run view --repo "${repo}" --job "${jobId}" --log`)
    return logsResult.ok ? logsResult.result : null
  }
}

/** Git CLI wrapper class */
class GitCli {
  static getCurrentSha() {
    return Util.execCommand('git rev-parse HEAD')
  }

  static getRemoteUrl() {
    return Util.execCommand('git remote get-url origin')
  }
}

/** Output helper class */
class Output {
  /**
   * @param {string} [text]
   */
  static log(text = '') {
    console.log(text)
  }

  /**
   * @param {string} text
   */
  static error(text) {
    console.log()
    console.error(`${colors.red}Error: ${text}${colors.reset}`)
  }

  /**
   * @param {string} text
   */
  static success(text) {
    console.log()
    console.log(`${colors.green}${text}${colors.reset}`)
  }

  /**
   * @param {string} text
   */
  static info(text) {
    console.log()
    console.log(`${colors.blue}${text}${colors.reset}`)
  }

  /**
   * @param {string} text
   */
  static warning(text) {
    console.log()
    console.log(`${colors.yellow}${text}${colors.reset}`)
  }

  /**
   * @param {string} text
   */
  static h1(text) {
    console.log(`${colors.bold}# ${text}${colors.reset}`)
  }

  /**
   * @param {string} text
   */
  static h2(text) {
    console.log()
    console.log(`${colors.bold}## ${text}${colors.reset}`)
  }
}

/** Reusable utilities */
class Util {
  /**
   * @param {number} ms
   */
  static sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  /**
   * @param {string} output
   */
  static parseJsonLines(output) {
    if (!output) return []

    return output
      .split('\n')
      .filter((line) => line.trim())
      .map((line) => JSON.parse(line))
  }

  /**
   * @param {string} sha
   */
  static validateSha(sha) {
    if (!sha) return false
    return /^[a-f0-9]{7,40}$/i.test(sha)
  }

  /**
   * @param {string} status
   * @param {string|null} conclusion
   */
  static formatStatus(status, conclusion) {
    switch (status) {
      case 'queued':
        return `${colors.yellow}QUEUED${colors.reset}`
      case 'in_progress':
        return `${colors.blue}RUNNING${colors.reset}`
    }
    switch (conclusion) {
      case 'success':
        return `${colors.green}SUCCESS${colors.reset}`
      case 'failure':
        return `${colors.red}FAILURE${colors.reset}`
      case 'cancelled':
        return `${colors.yellow}CANCELLED${colors.reset}`
      case 'skipped':
        return `${colors.dim}SKIPPED${colors.reset}`
    }
    return 'UNKNOWN'
  }

  /**
   * @param {Date|string|null} startedAt
   * @param {Date|string|null} updatedAt
   */
  static formatDuration(startedAt, updatedAt) {
    if (!startedAt || !updatedAt) return 'N/A'

    const start = new Date(startedAt)
    const end = new Date(updatedAt)
    const diffMs = end.getTime() - start.getTime()
    const seconds = Math.round(diffMs / 1000)
    
    if (seconds < 60) {
      return `${seconds}s`
    }
    
    const minutes = Math.floor(seconds / 60)
    if (minutes < 60) {
      const remainingSeconds = seconds % 60
      return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`
    }
    
    const hours = Math.floor(minutes / 60)
    if (hours < 24) {
      const remainingMinutes = minutes % 60
      return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`
    }
    
    const days = Math.floor(hours / 24)
    const remainingHours = hours % 24
    return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days}d`
  }

  /**
   * @param {string} command
   * @param {import('node:child_process').ExecSyncOptions} [execSyncOptions]
   * @returns {ExecCommandResult}
   */
  static execCommand(command, execSyncOptions = {}) {
    try {
      const result = execSync(command, {
        encoding: 'utf-8',
        stdio: 'pipe',
        ...execSyncOptions,
      })

      const trimmedResult = result.toString().trim()

      if (process.env.DEBUG) {
        Output.log(
          `> Running \`\`${command}\`\` => \`\`${JSON.stringify(trimmedResult).substring(0, 50)}\`\``,
        )
      }

      return { ok: true, result: trimmedResult }
    } catch (error) {
      if (process.env.DEBUG) {
        Output.log(`> Running \`\`${command}\`\` => error`)
      }

      // @ts-expect-error - error.status exists on ExecSyncError
      return { ok: false, code: error.status || 1 }
    }
  }
}

ShowLogAction.main().catch((/** @type {Error} */ error) => {
  Output.error(error.message)
  process.exit(1)
})
